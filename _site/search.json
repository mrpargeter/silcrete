[
  {
    "objectID": "step-2-silcrete_join_wood_density.html",
    "href": "step-2-silcrete_join_wood_density.html",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(readr)\nlibrary(readxl)\nlibrary(janitor)\n\n\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\nCode\nlibrary(glue)\nlibrary(fs)\n\n# Create output folder\ndir_create(params$outdir)\n\n# Utility: squish whitespace and lower-case for robust joins\nnormalize_key &lt;- function(x) {\n  x %&gt;%\n    as.character() %&gt;%\n    stringr::str_replace_all(\"\\\\s+\", \" \") %&gt;%\n    stringr::str_trim() %&gt;%\n    tolower()\n}\n\n# Utility: resolve a file path (try given path, else search by basename)\nresolve_file &lt;- function(path) {\n  if (fs::file_exists(path)) return(path)\n  bn &lt;- basename(path)\n  found &lt;- tryCatch(\n    fs::dir_ls(path=\".\", recurse=TRUE, type=\"file\", regexp=paste0(bn,\"$\")),\n    error=function(e) character(0)\n  )\n  if (length(found) &gt; 0) return(found[[1]])\n  stop(glue(\"File not found: {path}. Working dir: {getwd()}\"))\n}"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density.html#load-both-datasets",
    "href": "step-2-silcrete_join_wood_density.html#load-both-datasets",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "1) Load both datasets",
    "text": "1) Load both datasets\n\n\nCode\nmain_path &lt;- resolve_file(params$main_csv)\nwood_path &lt;- resolve_file(params$wood_xlsx)\n\nmessage(glue(\"Main CSV:  {main_path}\"))\n\n\nMain CSV:  wide-to-long_data_COMBINED_with_parsed_flake_AND_fuelwood.csv\n\n\nCode\nmessage(glue(\"Wood XLSX: {wood_path}\"))\n\n\nWood XLSX: wood densities.xlsx\n\n\nCode\nmain_raw &lt;- readr::read_csv(main_path, show_col_types = FALSE)\nwood_raw &lt;- readxl::read_excel(wood_path)\n\n# Clean column names to snake_case for safety\nmain &lt;- janitor::clean_names(main_raw)\nwood &lt;- janitor::clean_names(wood_raw)\n\ncat(\"Main columns:\", paste(names(main), collapse=\", \"), \"\\n\")\n\n\nMain columns: method, scale, distance, treatment, heating_condition, flake, nodule_number, nodule_sub_number, flake_number, average_curvature, standard_deviation, sheet, fuelwood \n\n\nCode\ncat(\"Wood columns:\", paste(names(wood), collapse=\", \"), \"\\n\")\n\n\nWood columns: fuelwood, wood_density, wood_density_group"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density.html#prepare-keys-and-density-field",
    "href": "step-2-silcrete_join_wood_density.html#prepare-keys-and-density-field",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "2) Prepare keys and density field",
    "text": "2) Prepare keys and density field\n\n\nCode\n# Ensure there is a 'fuelwood' column in both\nif (!\"fuelwood\" %in% names(main)) stop(\"The main CSV must contain a 'fuelwood' column.\")\nif (!\"fuelwood\" %in% names(wood)) {\n  # try to map likely variants\n  poss &lt;- grep(\"^fuel[_ ]?wood$|^wood$\", names(wood), ignore.case = TRUE, value = TRUE)\n  if (length(poss) == 0) stop(\"The wood densities file needs a 'fuelwood' column (or a close variant).\")\n  if (length(poss) &gt; 0) {\n    message(glue(\"Mapping wood densities column '{poss[1]}' -&gt; 'fuelwood'\"))\n    wood &lt;- wood %&gt;% rename(fuelwood = all_of(poss[1]))\n  }\n}\n\n# Ensure there is a numeric wood density column; prefer 'wood_density'\ndensity_col &lt;- NULL\nif (\"wood_density\" %in% names(wood)) density_col &lt;- \"wood_density\"\nif (is.null(density_col)) {\n  # look for candidates like density, dens_g_cm3, etc.\n  cand &lt;- grep(\"wood.*dens|^density$|dens|g.?/?.?cm3|gcm3|gcc|specific_gravity\", names(wood),\n               ignore.case = TRUE, value = TRUE)\n  if (length(cand) == 0) {\n    stop(\"Could not find a wood density column in the wood densities file.\")\n  } else {\n    density_col &lt;- cand[1]\n    message(glue(\"Using '{density_col}' as wood density and renaming to 'wood_density'\"))\n    wood &lt;- wood %&gt;% rename(wood_density = all_of(density_col))\n  }\n\n# Ensure there is a wood density group column named 'wood_density_group'\nif (!\"wood_density_group\" %in% names(wood)) {\n  cand_grp &lt;- grep(\"group\", names(wood), ignore.case = TRUE, value = TRUE)\n  if (length(cand_grp) &gt; 0) {\n    message(glue(\"Using '{cand_grp[1]}' as wood density group and renaming to 'wood_density_group'\"))\n    wood &lt;- wood %&gt;% rename(wood_density_group = all_of(cand_grp[1]))\n  } else {\n    message(\"No 'wood_density_group' column found in wood densities file; creating as NA.\")\n    wood &lt;- wood %&gt;% mutate(wood_density_group = NA_character_)\n  }\n}\n}\n\n# Normalize the join key for both frames\nmain &lt;- main %&gt;% mutate(fuelwood_key = normalize_key(fuelwood))\nwood &lt;- wood %&gt;% mutate(fuelwood_key = normalize_key(fuelwood))\n\n# Check for missing keys\nmain_missing &lt;- sum(is.na(main$fuelwood_key) | main$fuelwood_key == \"\")\nwood_missing &lt;- sum(is.na(wood$fuelwood_key) | wood$fuelwood_key == \"\")\nmessage(glue(\"Empty/NA fuelwood keys — main: {main_missing}, wood: {wood_missing}\"))\n\n\nEmpty/NA fuelwood keys — main: 0, wood: 0"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density.html#diagnose-duplicates-in-wood-table-and-de-duplicate-safely",
    "href": "step-2-silcrete_join_wood_density.html#diagnose-duplicates-in-wood-table-and-de-duplicate-safely",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "3) Diagnose duplicates in wood table and de-duplicate safely",
    "text": "3) Diagnose duplicates in wood table and de-duplicate safely\n\n\nCode\nwood_dupes &lt;- wood %&gt;%\n  count(fuelwood_key, name = \"n_rows\") %&gt;%\n  filter(n_rows &gt; 1)\n\nif (nrow(wood_dupes) &gt; 0) {\n  message(glue(\"Found {nrow(wood_dupes)} duplicated fuelwood keys in wood densities; aggregating by mean density.\"))\n  # Save the list for review\n  write_csv(wood_dupes, file.path(params$outdir, \"wood_duplicates.csv\"))\n}\n\n# Aggregate wood densities by mean per key to avoid row multiplication on join\nwood_agg &lt;- wood %&gt;%\n  group_by(fuelwood_key) %&gt;%\n  summarise(\n    wood_density = suppressWarnings(mean(as.numeric(wood_density), na.rm = TRUE)),\n    wood_density_group = dplyr::first(na.omit(wood_density_group)),\n    n_source_rows = dplyr::n(),\n    .groups = \"drop\"\n  )"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density.html#left-join-and-verify",
    "href": "step-2-silcrete_join_wood_density.html#left-join-and-verify",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "4) Left join and verify",
    "text": "4) Left join and verify\n\n\nCode\nn_before &lt;- nrow(main)\nmerged &lt;- main %&gt;%\n  left_join(wood_agg, by = \"fuelwood_key\")\n\nn_after &lt;- nrow(merged)\nif (n_after != n_before) {\n  warning(glue(\"Row count changed after join (before: {n_before}, after: {n_after}).\"))\n} else {\n  message(glue(\"Row count unchanged after join: {n_after} rows.\"))\n}\n\n\nRow count unchanged after join: 770 rows.\n\n\nCode\n# How many rows didn't find a wood density?\nn_na_density &lt;- sum(is.na(merged$wood_density))\npct_na &lt;- round(100 * n_na_density / nrow(merged), 2)\nmessage(glue(\"Rows with missing wood_density after join: {n_na_density} ({pct_na}%).\"))\n\n\nRows with missing wood_density after join: 170 (22.08%).\n\n\nCode\n# Identify any fuelwood keys in main that failed to match\nunmatched &lt;- merged %&gt;%\n  filter(is.na(wood_density)) %&gt;%\n  distinct(fuelwood, fuelwood_key) %&gt;%\n  arrange(fuelwood)\nif (nrow(unmatched) &gt; 0) {\n  write_csv(unmatched, file.path(params$outdir, \"unmatched_fuelwood_in_main.csv\"))\n  message(glue(\"Wrote list of unmatched main fuelwood values to 'unmatched_fuelwood_in_main.csv'\"))\n}\n\n\nWrote list of unmatched main fuelwood values to 'unmatched_fuelwood_in_main.csv'\n\n\nCode\n# Keep original fuelwood, drop helper key if you like; retain diagnostic columns\nmerged_out &lt;- merged %&gt;% relocate(wood_density, wood_density_group, .after = fuelwood)\n\n# Quick peek\nmerged_out %&gt;% select(fuelwood, wood_density, wood_density_group) %&gt;% head(12)\n\n\n# A tibble: 12 × 3\n   fuelwood wood_density wood_density_group\n   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;             \n 1 none              NaN &lt;NA&gt;              \n 2 none              NaN &lt;NA&gt;              \n 3 none              NaN &lt;NA&gt;              \n 4 none              NaN &lt;NA&gt;              \n 5 none              NaN &lt;NA&gt;              \n 6 none              NaN &lt;NA&gt;              \n 7 none              NaN &lt;NA&gt;              \n 8 none              NaN &lt;NA&gt;              \n 9 none              NaN &lt;NA&gt;              \n10 none              NaN &lt;NA&gt;              \n11 none              NaN &lt;NA&gt;              \n12 none              NaN &lt;NA&gt;"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density.html#save-merged-csv",
    "href": "step-2-silcrete_join_wood_density.html#save-merged-csv",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "5) Save merged CSV",
    "text": "5) Save merged CSV\n\n\nCode\nout_csv &lt;- file.path(params$outdir, \"wide-to-long_with_wood_density.csv\")\nreadr::write_csv(merged_out, out_csv)\nmessage(glue(\"Saved merged CSV to: {out_csv}\"))\n\n\nSaved merged CSV to: ./wide-to-long_with_wood_density.csv"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density.html#summary-tables",
    "href": "step-2-silcrete_join_wood_density.html#summary-tables",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "6) Summary tables",
    "text": "6) Summary tables\n\n\nCode\n# Summary by fuelwood\nsummary_by_fuelwood &lt;- merged_out %&gt;%\n  group_by(fuelwood) %&gt;%\n  summarise(\n    n = dplyr::n(),\n    wood_density = unique(wood_density)[1],\n    .groups = \"drop\"\n  ) %&gt;%\n  arrange(fuelwood)\n\n# Density completeness by method/scale/distance/heating\ncompleteness &lt;- merged_out %&gt;%\n  mutate(has_density = !is.na(wood_density)) %&gt;%\n  count(method, scale, distance, heating_condition, has_density) %&gt;%\n  tidyr::pivot_wider(names_from = has_density, values_from = n, values_fill = 0, names_prefix = \"has_density_\") %&gt;%\n  arrange(method, scale, distance, heating_condition)\n\n# Print\nsummary_by_fuelwood %&gt;% head(20) %&gt;% knitr::kable(digits = 3, caption = \"First 20 fuelwood entries with densities\")\n\n\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n\n\nWarning in attr(x, \"format\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n\n\n\nFirst 20 fuelwood entries with densities\n\n\nfuelwood\nn\nwood_density\n\n\n\n\nOlea exasperata\n50\n0.75\n\n\nProtea obtusifolia\n30\n0.58\n\n\nProtea susannae\n20\n0.60\n\n\nPterocelastrus tricuspidatus\n100\n0.65\n\n\nSearsia glauca\n210\n0.72\n\n\nSearsia lucida\n190\n0.70\n\n\nnone\n170\nNaN\n\n\n\n\n\nCode\ncompleteness %&gt;% knitr::kable(digits = 0, caption = \"Wood density completeness by strata\")\n\n\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n\n\n\nWood density completeness by strata\n\n\n\n\n\n\n\n\n\n\nmethod\nscale\ndistance\nheating_condition\nhas_density_TRUE\nhas_density_FALSE\n\n\n\n\nnew method\n10um\nNA\nember\n26\n0\n\n\nnew method\n10um\nNA\nsand\n34\n0\n\n\nnew method\n10um\nNA\nunheated\n0\n17\n\n\nnew method\n20um\nNA\nember\n26\n0\n\n\nnew method\n20um\nNA\nsand\n34\n0\n\n\nnew method\n20um\nNA\nunheated\n0\n17\n\n\nold method\n10um\n0\nember\n26\n0\n\n\nold method\n10um\n0\nsand\n34\n0\n\n\nold method\n10um\n0\nunheated\n0\n17\n\n\nold method\n10um\n0\nember\n26\n0\n\n\nold method\n10um\n0\nsand\n34\n0\n\n\nold method\n10um\n0\nunheated\n0\n17\n\n\nold method\n10um\n1\nember\n26\n0\n\n\nold method\n10um\n1\nsand\n34\n0\n\n\nold method\n10um\n1\nunheated\n0\n17\n\n\nold method\n10um\n2\nember\n26\n0\n\n\nold method\n10um\n2\nsand\n34\n0\n\n\nold method\n10um\n2\nunheated\n0\n17\n\n\nold method\n20um\n0\nember\n26\n0\n\n\nold method\n20um\n0\nsand\n34\n0\n\n\nold method\n20um\n0\nunheated\n0\n17\n\n\nold method\n20um\n0\nember\n26\n0\n\n\nold method\n20um\n0\nsand\n34\n0\n\n\nold method\n20um\n0\nunheated\n0\n17\n\n\nold method\n20um\n1\nember\n26\n0\n\n\nold method\n20um\n1\nsand\n34\n0\n\n\nold method\n20um\n1\nunheated\n0\n17\n\n\nold method\n20um\n2\nember\n26\n0\n\n\nold method\n20um\n2\nsand\n34\n0\n\n\nold method\n20um\n2\nunheated\n0\n17"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html",
    "href": "step-3_silcrete_edge_sharpness_analysis.html",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "",
    "text": "Here we analyze how heating technique (ember vs sand) and wood fuel density affect silcrete flake edge sharpness (average curvature).\n\nExclude unheated observations.\nAnalyze best fit circle method (10 µm and 20 µm).\nAnalyze three point stepping method at distances 0.1, 0.5, 1.0, 2.0 cm and scales 10 µm, 20 µm.\nFit OLS with interaction: average_curvature ~ wood_density * heating_condition.\nUse Type II ANOVA and HC3 robust SE for inference.\nReport adjusted means (EMMs) for heating condition at mean wood density.\n\n\n\n\nlibrary(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n\n\n\n\nfit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, wood_density, heating_condition)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ wood_density * heating_condition, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  at %&gt;% select(term, everything())\n}\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  mean_wd &lt;- mean(df$wood_density, na.rm = TRUE)\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition,\n                         at = list(wood_density = mean_wd),\n                         type = \"response\")\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  rng &lt;- range(df$wood_density, na.rm = TRUE)\n  grid &lt;- expand.grid(\n    wood_density = seq(rng[1], rng[2], length.out = 200),\n    heating_condition = sort(unique(df$heating_condition))\n  )\n  pr &lt;- as.data.frame(predict(mdl, newdata = grid, se.fit = TRUE))\n  grid$fit &lt;- pr$fit\n\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")     # coral, cyan\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)                 # circle, triangle\n  ltys &lt;- c(\"sand\" = 1, \"ember\" = 2)                     # solid, dashed\n\n  ggplot(df, aes(x = wood_density, y = average_curvature, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), size = 2, alpha = 0.8) +\n    geom_smooth(data = grid,\n                aes(x = wood_density, y = fit, linetype = heating_condition),\n                se = FALSE, method = \"lm\", formula = y ~ x) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    scale_linetype_manual(values = ltys, name = NULL) +\n    labs(title = title,\n         x = expression(paste(\"Wood density (g/\", cm^3, \")\")),\n         y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) +\n    theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html#packages-data",
    "href": "step-3_silcrete_edge_sharpness_analysis.html#packages-data",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "",
    "text": "library(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html#helper-functions",
    "href": "step-3_silcrete_edge_sharpness_analysis.html#helper-functions",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "",
    "text": "fit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, wood_density, heating_condition)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ wood_density * heating_condition, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  at %&gt;% select(term, everything())\n}\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  mean_wd &lt;- mean(df$wood_density, na.rm = TRUE)\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition,\n                         at = list(wood_density = mean_wd),\n                         type = \"response\")\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  rng &lt;- range(df$wood_density, na.rm = TRUE)\n  grid &lt;- expand.grid(\n    wood_density = seq(rng[1], rng[2], length.out = 200),\n    heating_condition = sort(unique(df$heating_condition))\n  )\n  pr &lt;- as.data.frame(predict(mdl, newdata = grid, se.fit = TRUE))\n  grid$fit &lt;- pr$fit\n\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")     # coral, cyan\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)                 # circle, triangle\n  ltys &lt;- c(\"sand\" = 1, \"ember\" = 2)                     # solid, dashed\n\n  ggplot(df, aes(x = wood_density, y = average_curvature, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), size = 2, alpha = 0.8) +\n    geom_smooth(data = grid,\n                aes(x = wood_density, y = fit, linetype = heating_condition),\n                se = FALSE, method = \"lm\", formula = y ~ x) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    scale_linetype_manual(values = ltys, name = NULL) +\n    labs(title = title,\n         x = expression(paste(\"Wood density (g/\", cm^3, \")\")),\n         y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) +\n    theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html#summary-figure-old-only",
    "href": "step-3_silcrete_edge_sharpness_analysis.html#summary-figure-old-only",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "3.1 Summary figure (OLD only)",
    "text": "3.1 Summary figure (OLD only)\n\nthree_point_stepping_summary_plot&lt;-if (nrow(adj_means_old) &gt; 0) {\n  ggplot(adj_means_old,\n         aes(x = factor(distance),\n             y = pred_mean,\n             group = interaction(heating_condition, scale),\n             colour = heating_condition, shape = scale, linetype = heating_condition)) +\n    geom_point(position = position_dodge(width = 0.3), size = 2.2) +\n    geom_line(position = position_dodge(width = 0.3)) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high),\n                  width = 0.08, position = position_dodge(width = 0.3)) +\n    scale_colour_manual(values = c(\"sand\"=\"#F26B6B\",\"ember\"=\"#18C3C8\"), name = NULL) +\n    scale_linetype_manual(values = c(\"sand\"=1,\"ember\"=2), name = NULL) +\n    labs(x = \"Distance (cm)\", y = \"Adjusted mean edge sharpness\",\n         title = \"Adjusted means (±95% CI) by heating condition — three point stepping\") +\n    theme_minimal(base_size = 13) +\n    theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html#figure-caption-for-manuscript",
    "href": "step-3_silcrete_edge_sharpness_analysis.html#figure-caption-for-manuscript",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "4.1 Figure caption (for manuscript)",
    "text": "4.1 Figure caption (for manuscript)"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html#table-1.-data-sample-summary",
    "href": "step-3_silcrete_edge_sharpness_analysis.html#table-1.-data-sample-summary",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "5.1 Table 1. Data sample summary",
    "text": "5.1 Table 1. Data sample summary\nThis table summarizes the analytical sample used in this notebook by method, scale, distance, and heating condition (saved to file)."
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis.html#figures-saved-to-file",
    "href": "step-3_silcrete_edge_sharpness_analysis.html#figures-saved-to-file",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density",
    "section": "5.2 Figures (saved to file)",
    "text": "5.2 Figures (saved to file)\nThis recreates the papers plots and exports them to high-resolution PNG and PDF suitable for publication.\n\n\n\n\n\n\n\n\nFigure 1: Comparison of adjusted means: best fit circle vs three point stepping (10µm & 20µm)"
  },
  {
    "objectID": "step 1-wide-to-long.html",
    "href": "step 1-wide-to-long.html",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "",
    "text": "library(tidyverse)\nlibrary(readxl)\nlibrary(readr)\nlibrary(stringr)"
  },
  {
    "objectID": "step 1-wide-to-long.html#inputs",
    "href": "step 1-wide-to-long.html#inputs",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "Inputs",
    "text": "Inputs\n\n# Workbook with multiple tabs to parse\nin_path &lt;- \"wide-to-long data.xlsx\"   # change if needed\n\n# Fuelwood CSV with columns 'flake' and 'fuelwood'\nfuel_csv &lt;- \"Final data-chatgpt.csv\"  # change if needed\n\n# Output CSV (final joined only)\nout_finaljoin_csv  &lt;- \"wide-to-long_data_COMBINED_with_parsed_flake_AND_fuelwood.csv\""
  },
  {
    "objectID": "step 1-wide-to-long.html#helper-functions",
    "href": "step 1-wide-to-long.html#helper-functions",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "Helper functions",
    "text": "Helper functions\n\n# Clean a cell to character or NA\nnorm_cell &lt;- function(x) {\n  if (is.na(x)) return(NA_character_)\n  s &lt;- trimws(as.character(x))\n  ifelse(nchar(s) == 0, NA_character_, s)\n}\n\n# First non-empty value in a 0-indexed row (Excel-style 0=first row)\nfirst_nonnull_in_row &lt;- function(df, row_idx0) {\n  row_idx &lt;- row_idx0 + 1\n  if (row_idx &gt; nrow(df)) return(NA_character_)\n  row &lt;- df[row_idx, , drop = FALSE]\n  vals &lt;- purrr::map_chr(row, ~ norm_cell(.x))\n  vals &lt;- vals[!is.na(vals)]\n  if (length(vals) == 0) return(NA_character_)\n  vals[[1]]\n}\n\n# Vectorized normalizer for flake IDs\nnorm_flake_robust &lt;- function(x) {\n  s &lt;- ifelse(is.na(x), NA_character_, toupper(trimws(as.character(x))))\n\n  # Replace whitespace, periods, and hyphens -&gt; underscore; collapse runs\n  s &lt;- stringr::str_replace_all(s, \"\\\\s+\", \"_\")\n  s &lt;- stringr::str_replace_all(s, \"[-.]\", \"_\")\n  s &lt;- stringr::str_replace_all(s, \"_+\", \"_\")\n\n  # Normalize leading O/N variants to 'ON_'\n  s &lt;- stringr::str_replace(s, \"^(O[._]?_?N[._]?_?)\", \"ON_\")\n  s &lt;- stringr::str_replace_all(s, \"_+\", \"_\")\n\n  # Ensure 'ON' followed by a digit has underscore: 'ON1' -&gt; 'ON_1'\n  s &lt;- stringr::str_replace(s, \"^ON(?=\\\\d)\", \"ON_\")\n\n  # If first token after ON_ is like '54A', make it '54_A'\n  s &lt;- stringr::str_replace(s, \"^(ON_)(\\\\d+)([A-Z]+)\", \"\\\\1\\\\2_\\\\3\")\n\n  s\n}\n\n# Parse flake ID into nodule number, nodule sub number, and flake number (retain letters in flake number)\nparse_flake_id &lt;- function(flake_raw) {\n  if (is.na(flake_raw)) return(tibble(`nodule number`=NA_integer_,\n                                      `nodule sub number`=NA_character_,\n                                      `flake number`=NA_character_))\n  s &lt;- trimws(as.character(flake_raw))\n  s_norm &lt;- gsub(\"\\\\.\", \"_\", s)            # periods -&gt; underscores\n  parts &lt;- str_split(s_norm, \"_\", simplify = FALSE)[[1]]\n  parts &lt;- parts[parts != \"\"]\n  # strip leading O and N\n  while (length(parts) &gt; 0 && toupper(parts[1]) == \"O\") parts &lt;- parts[-1]\n  while (length(parts) &gt; 0 && toupper(parts[1]) == \"N\") parts &lt;- parts[-1]\n  rest &lt;- if (length(parts) &gt; 0) paste(parts, collapse=\"_\") else \"\"\n\n  split_digits_letters &lt;- function(token) {\n    # returns list(digits, letters)\n    m1 &lt;- str_match(token, \"^(\\\\d+)([A-Za-z]+)?$\")\n    if (!any(is.na(m1))) {\n      return(list(d = m1[,2], L = ifelse(is.na(m1[,3]), \"\", m1[,3])))\n    }\n    m2 &lt;- str_match(token, \"^([A-Za-z]+)(\\\\d+)$\")\n    if (!any(is.na(m2))) {\n      return(list(d = m2[,3], L = m2[,2]))\n    }\n    digits &lt;- str_replace_all(token, \"[^0-9]\", \"\")\n    letters &lt;- str_replace_all(token, \"[^A-Za-z]\", \"\")\n    list(d = ifelse(nchar(digits)&gt;0, digits, NA_character_),\n         L = ifelse(nchar(letters)&gt;0, letters, \"\"))\n  }\n\n  nodule_num &lt;- NA_integer_\n  nodule_sub &lt;- \"\"\n  flake_num  &lt;- NA_character_\n\n  if (str_detect(rest, \"-\")) {\n    # Pattern like \"32A-21\"\n    left  &lt;- str_split(rest, \"-\", n = 2, simplify = TRUE)[,1]\n    right &lt;- str_split(rest, \"-\", n = 2, simplify = TRUE)[,2]\n    left_main &lt;- str_split(left, \"_\", simplify = TRUE)[,1]\n    sl &lt;- split_digits_letters(left_main)\n    if (!is.na(sl$d)) nodule_num &lt;- as.integer(sl$d)\n    nodule_sub &lt;- ifelse(nchar(sl$L) &gt; 0, sl$L, \"\")\n    flake_num &lt;- trimws(right)  # retain letters if present\n  } else {\n    tokens &lt;- if (nchar(rest) &gt; 0) str_split(rest, \"_\", simplify = FALSE)[[1]] else character(0)\n    tokens &lt;- tokens[tokens != \"\"]\n    if (length(tokens) &gt;= 3) {\n      s1 &lt;- split_digits_letters(tokens[1])\n      s2 &lt;- split_digits_letters(tokens[2])\n      s3 &lt;- split_digits_letters(tokens[3])\n      if (!is.na(s1$d)) nodule_num &lt;- as.integer(s1$d)\n      nodule_sub &lt;- ifelse(nchar(s2$L) &gt; 0, s2$L,\n                        ifelse(nchar(s1$L) &gt; 0, s1$L, ifelse(nchar(s3$L) &gt; 0, s3$L, \"\")))\n      flake_num &lt;- tokens[3]  # keep as-is\n    } else if (length(tokens) == 2) {\n      s1 &lt;- split_digits_letters(tokens[1])\n      if (!is.na(s1$d)) nodule_num &lt;- as.integer(s1$d)\n      nodule_sub &lt;- ifelse(nchar(s1$L) &gt; 0, s1$L, \"\")\n      flake_num &lt;- tokens[2]\n    } else if (length(tokens) == 1) {\n      s1 &lt;- split_digits_letters(tokens[1])\n      if (!is.na(s1$d)) nodule_num &lt;- as.integer(s1$d)\n      nodule_sub &lt;- ifelse(nchar(s1$L) &gt; 0, s1$L, \"\")\n      flake_num &lt;- NA_character_\n    }\n  }\n\n  tibble(`nodule number` = nodule_num,\n         `nodule sub number` = ifelse(nchar(nodule_sub)&gt;0, nodule_sub, NA_character_),\n         `flake number` = flake_num)\n}\n\n# Parse one sheet with the agreed structure\nparse_sheet_to_long &lt;- function(path, sheet_name) {\n  df &lt;- read_excel(path, sheet = sheet_name, col_names = FALSE)\n  df &lt;- as.data.frame(df)\n  n_rows &lt;- nrow(df); n_cols &lt;- ncol(df)\n\n  norm &lt;- function(i, j) norm_cell(df[i, j])\n\n  # Identify 3-col blocks by header pattern in row 2 (index 1)\n  triplets &lt;- list()\n  for (c in 1:(n_cols-2)) {\n    r1 &lt;- norm(2, c)\n    r2 &lt;- norm(2, c+1)\n    r3 &lt;- norm(2, c+2)\n    if (identical(r1, \"Flake\") && identical(r2, \"Average Curvature\") && identical(r3, \"Standard Deviation\")) {\n      tname &lt;- norm(1, c)\n      # If merged header left is empty, walk left to find the treatment label\n      if (is.na(tname)) {\n        cc &lt;- c\n        while (cc &gt;= 1 && (is.na(tname) || tname == \"\")) {\n          tname &lt;- norm(1, cc)\n          cc &lt;- cc - 1\n        }\n      }\n      if (!is.na(tname) && tname != \"\") {\n        triplets &lt;- append(triplets, list(list(col = c, treatment = tname)))\n      }\n    }\n  }\n\n  # Stop data at row 21 (0-indexed 20) if that row has any content; metadata live at rows 21-23\n  data_end &lt;- n_rows\n  if (n_rows &gt;= 21) {\n    row21_has_content &lt;- any(!is.na(df[21, ]))\n    if (row21_has_content) data_end &lt;- 20\n  }\n\n  # Metadata rows (0-indexed 20/21/22 =&gt; R rows 21/22/23)\n  method_val   &lt;- first_nonnull_in_row(df, 20)\n  scale_val    &lt;- first_nonnull_in_row(df, 21)\n  distance_val &lt;- first_nonnull_in_row(df, 22)\n\n  # Build long records\n  recs &lt;- list()\n  for (tr in triplets) {\n    c &lt;- tr$col\n    tname &lt;- tr$treatment\n    flake_col &lt;- c\n    avg_col   &lt;- c + 1\n    sd_col    &lt;- c + 2\n\n    if (data_end &lt; 3) next  # no data rows\n\n    for (r in 3:data_end) {   # data start after two header rows\n      flake &lt;- norm_cell(df[r, flake_col])\n      if (!is.na(flake)) {\n        avg &lt;- suppressWarnings(as.numeric(df[r, avg_col]))\n        sd  &lt;- suppressWarnings(as.numeric(df[r, sd_col]))\n        recs &lt;- append(recs, list(tibble(\n          method = method_val,\n          scale = scale_val,\n          distance = distance_val,\n          treatment = tname,\n          flake = flake,\n          `average curvature` = avg,\n          `standard deviation` = sd,\n          sheet = sheet_name\n        )))\n      }\n    }\n  }\n  if (length(recs) == 0) {\n    return(tibble())\n  }\n  bind_rows(recs)\n}"
  },
  {
    "objectID": "step 1-wide-to-long.html#parse-all-sheets-and-combine",
    "href": "step 1-wide-to-long.html#parse-all-sheets-and-combine",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "Parse all sheets and combine",
    "text": "Parse all sheets and combine\n\nsheets &lt;- excel_sheets(in_path)\nsheets\n\n [1] \"old-0.1-10\" \"old-0.1-20\" \"old-0.5-10\" \"old-0.5-20\" \"old-1.0-10\"\n [6] \"old-1.0-20\" \"old-2.0-10\" \"old-2.0-20\" \"new-10\"     \"new-20\"    \n\n\n\n# Parse and combine\ndfs &lt;- purrr::map(sheets, ~ parse_sheet_to_long(in_path, .x))\nnames(dfs) &lt;- sheets\nper_sheet_counts &lt;- purrr::map_int(dfs, nrow)\nper_sheet_counts\n\nold-0.1-10 old-0.1-20 old-0.5-10 old-0.5-20 old-1.0-10 old-1.0-20 old-2.0-10 \n        77         77         77         77         77         77         77 \nold-2.0-20     new-10     new-20 \n        77         77         77 \n\ncombined &lt;- bind_rows(dfs)\n\n# Add heating_condition from treatment mapping\nheating_map &lt;- function(t) {\n  u &lt;- toupper(trimws(as.character(t)))\n  if (u %in% c(\"F1F\",\"F2F\")) return(\"ember\")\n  if (u %in% c(\"F1S\",\"F2S\")) return(\"sand\")\n  if (u %in% c(\"UNHEATED\"))  return(\"unheated\")\n  return(NA_character_)\n}\ncombined &lt;- combined %&gt;%\n  mutate(heating_condition = vapply(treatment, heating_map, FUN.VALUE = character(1))) %&gt;%\n  relocate(heating_condition, .after = treatment)"
  },
  {
    "objectID": "step 1-wide-to-long.html#parse-flake-ids-retain-ab-in-flake-number-and-save",
    "href": "step 1-wide-to-long.html#parse-flake-ids-retain-ab-in-flake-number-and-save",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "Parse flake IDs (retain A/B in flake number) and save",
    "text": "Parse flake IDs (retain A/B in flake number) and save\n\nparsed_list &lt;- combined %&gt;%\n  mutate(parsed = purrr::map(flake, parse_flake_id)) %&gt;%\n  unnest(parsed)\n\n# Put parsed columns right after 'flake'\nparsed_ordered &lt;- parsed_list %&gt;%\n  relocate(`nodule number`, `nodule sub number`, `flake number`, .after = flake)\n\n# Sanity checks (expect 77 rows per sheet if input is correct)\ntable_per_sheet &lt;- parsed_ordered %&gt;% count(sheet, name = \"rows_per_sheet\")\ntable_per_sheet\n\n# A tibble: 10 × 2\n   sheet      rows_per_sheet\n   &lt;chr&gt;               &lt;int&gt;\n 1 new-10                 77\n 2 new-20                 77\n 3 old-0.1-10             77\n 4 old-0.1-20             77\n 5 old-0.5-10             77\n 6 old-0.5-20             77\n 7 old-1.0-10             77\n 8 old-1.0-20             77\n 9 old-2.0-10             77\n10 old-2.0-20             77\n\nnrow(parsed_ordered)\n\n[1] 770"
  },
  {
    "objectID": "step 1-wide-to-long.html#join-fuelwood-by-flake-robust-matching",
    "href": "step 1-wide-to-long.html#join-fuelwood-by-flake-robust-matching",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "Join fuelwood by flake (robust matching)",
    "text": "Join fuelwood by flake (robust matching)\n\n# Read fuelwood CSV and normalize column names to simple snake_case\nfuel &lt;- read_csv(fuel_csv, show_col_types = FALSE)\nnames(fuel) &lt;- names(fuel) %&gt;%\n  tolower() %&gt;%\n  str_replace_all(\"\\\\s+\", \"_\")\n\n# Identify flake and fuelwood columns (assumes they exist as 'flake' and 'fuelwood')\nflake_col &lt;- names(fuel)[which(names(fuel) == \"flake\")[1]]\nfuel_col  &lt;- names(fuel)[which(names(fuel) == \"fuelwood\")[1]]\n\nif (is.na(flake_col) || is.na(fuel_col)) {\n  stop(\"Could not find required columns in the fuel CSV. Expected 'flake' and 'fuelwood'.\")\n}\n\n# Build join keys\nleft_keyed &lt;- parsed_ordered %&gt;%\n  mutate(flake_join = norm_flake_robust(flake))\n\nfuel_map &lt;- fuel %&gt;%\n  transmute(flake_join = norm_flake_robust(.data[[flake_col]]),\n            fuelwood = .data[[fuel_col]]) %&gt;%\n  group_by(flake_join) %&gt;%\n  summarise(fuelwood = first(na.omit(fuelwood)), .groups = \"drop\")\n\n# Left join (retain all left columns + only fuelwood from the CSV)\nfinal_joined &lt;- left_keyed %&gt;%\n  left_join(fuel_map, by = \"flake_join\") %&gt;%\n  select(-flake_join)"
  },
  {
    "objectID": "step 1-wide-to-long.html#validation-match-rates-and-unmatched-summaries",
    "href": "step 1-wide-to-long.html#validation-match-rates-and-unmatched-summaries",
    "title": "Wide-to-Long Pipeline (CSV-only) + Fuelwood + Flake Parsing + Validation",
    "section": "Validation (match rates and unmatched summaries)",
    "text": "Validation (match rates and unmatched summaries)\n\n# Overall unmatched\noverall_unmatched &lt;- sum(is.na(final_joined$fuelwood))\noverall_rows &lt;- nrow(final_joined)\noverall_match_rate &lt;- 1 - overall_unmatched / overall_rows\n\n# Per-sheet unmatched\nvalidation_table &lt;- final_joined %&gt;%\n  group_by(sheet) %&gt;%\n  summarise(\n    rows = n(),\n    unmatched = sum(is.na(fuelwood)),\n    match_rate = 1 - unmatched / rows,\n    .groups = \"drop\"\n  ) %&gt;%\n  arrange(desc(unmatched))\n\nvalidation_table\n\n# A tibble: 10 × 4\n   sheet       rows unmatched match_rate\n   &lt;chr&gt;      &lt;int&gt;     &lt;int&gt;      &lt;dbl&gt;\n 1 new-10        77         0          1\n 2 new-20        77         0          1\n 3 old-0.1-10    77         0          1\n 4 old-0.1-20    77         0          1\n 5 old-0.5-10    77         0          1\n 6 old-0.5-20    77         0          1\n 7 old-1.0-10    77         0          1\n 8 old-1.0-20    77         0          1\n 9 old-2.0-10    77         0          1\n10 old-2.0-20    77         0          1\n\noverall_unmatched\n\n[1] 0\n\noverall_rows\n\n[1] 770\n\noverall_match_rate\n\n[1] 1\n\n\n\n# Save final joined dataset\nwrite_csv(final_joined, out_finaljoin_csv)\ncat(\"Wrote:\", out_finaljoin_csv, \"\\n\")\n\nWrote: wide-to-long_data_COMBINED_with_parsed_flake_AND_fuelwood.csv"
  },
  {
    "objectID": "step 3-OPTIONAL-silcrete_edge_sharpness_analysis_no_density.html",
    "href": "step 3-OPTIONAL-silcrete_edge_sharpness_analysis_no_density.html",
    "title": "Silcrete Edge Sharpness: Heating Technique Only (No Wood-Density Covariate)",
    "section": "",
    "text": "This document repeats the full analysis without using wood density as a covariate.\nAll models are of the form:\n[ ]\nAccordingly: - Results focus on the main effect of heating technique (ember vs sand). - Group means (± 95% CI) are estimated via emmeans (no adjustment for covariates). - We produce figures showing group means with 95% CI for each analysis subset. - Unheated observations are excluded, as before."
  },
  {
    "objectID": "step 3-OPTIONAL-silcrete_edge_sharpness_analysis_no_density.html#summary-figure-old-method-only",
    "href": "step 3-OPTIONAL-silcrete_edge_sharpness_analysis_no_density.html#summary-figure-old-method-only",
    "title": "Silcrete Edge Sharpness: Heating Technique Only (No Wood-Density Covariate)",
    "section": "6.1 Summary figure (OLD method only)",
    "text": "6.1 Summary figure (OLD method only)\n\nif (nrow(adj_means_old) &gt; 0) {\n  ggplot(adj_means_old,\n         aes(x = factor(distance), y = mean,\n             group = interaction(heating_condition, scale),\n             colour = heating_condition, shape = scale)) +\n    geom_point(position = position_dodge(width = 0.3), size = 2.5) +\n    geom_line(position = position_dodge(width = 0.3)) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high),\n                  width = 0.1, position = position_dodge(width = 0.3)) +\n    labs(x = \"Distance (cm)\", y = \"Mean edge sharpness\",\n         title = \"Group means ±95% CI by heating condition (OLD method)\",\n         colour = \"Heating\", shape = \"Scale\") +\n    theme_minimal(base_size = 12)\n}"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html",
    "href": "step-2-silcrete_join_wood_density (4).html",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(readr)\nlibrary(readxl)\nlibrary(janitor)\n\n\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\nCode\nlibrary(glue)\nlibrary(fs)\n\n# Create output folder\ndir_create(params$outdir)\n\n# Utility: squish whitespace and lower-case for robust joins\nnormalize_key &lt;- function(x) {\n  x %&gt;%\n    as.character() %&gt;%\n    stringr::str_replace_all(\"\\\\s+\", \" \") %&gt;%\n    stringr::str_trim() %&gt;%\n    tolower()\n}\n\n# Utility: resolve a file path (try given path, else search by basename)\nresolve_file &lt;- function(path) {\n  if (fs::file_exists(path)) return(path)\n  bn &lt;- basename(path)\n  found &lt;- tryCatch(\n    fs::dir_ls(path=\".\", recurse=TRUE, type=\"file\", regexp=paste0(bn,\"$\")),\n    error=function(e) character(0)\n  )\n  if (length(found) &gt; 0) return(found[[1]])\n  stop(glue(\"File not found: {path}. Working dir: {getwd()}\"))\n}"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html#load-both-datasets",
    "href": "step-2-silcrete_join_wood_density (4).html#load-both-datasets",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "1) Load both datasets",
    "text": "1) Load both datasets\n\n\nCode\nmain_path &lt;- resolve_file(params$main_csv)\nwood_path &lt;- resolve_file(params$wood_xlsx)\n\nmessage(glue(\"Main CSV:  {main_path}\"))\n\n\nMain CSV:  wide-to-long_data_COMBINED_with_parsed_flake_AND_fuelwood.csv\n\n\nCode\nmessage(glue(\"Wood XLSX: {wood_path}\"))\n\n\nWood XLSX: wood densities.xlsx\n\n\nCode\nmain_raw &lt;- readr::read_csv(main_path, show_col_types = FALSE)\nwood_raw &lt;- readxl::read_excel(wood_path)\n\n# Clean column names to snake_case for safety\nmain &lt;- janitor::clean_names(main_raw)\nwood &lt;- janitor::clean_names(wood_raw)\n\ncat(\"Main columns:\", paste(names(main), collapse=\", \"), \"\\n\")\n\n\nMain columns: method, scale, distance, treatment, heating_condition, flake, nodule_number, nodule_sub_number, flake_number, average_curvature, standard_deviation, sheet, fuelwood \n\n\nCode\ncat(\"Wood columns:\", paste(names(wood), collapse=\", \"), \"\\n\")\n\n\nWood columns: fuelwood, wood_density, wood_density_group"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html#prepare-keys-and-density-field",
    "href": "step-2-silcrete_join_wood_density (4).html#prepare-keys-and-density-field",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "2) Prepare keys and density field",
    "text": "2) Prepare keys and density field\n\n\nCode\n# Ensure there is a 'fuelwood' column in both\nif (!\"fuelwood\" %in% names(main)) stop(\"The main CSV must contain a 'fuelwood' column.\")\nif (!\"fuelwood\" %in% names(wood)) {\n  # try to map likely variants\n  poss &lt;- grep(\"^fuel[_ ]?wood$|^wood$\", names(wood), ignore.case = TRUE, value = TRUE)\n  if (length(poss) == 0) stop(\"The wood densities file needs a 'fuelwood' column (or a close variant).\")\n  if (length(poss) &gt; 0) {\n    message(glue(\"Mapping wood densities column '{poss[1]}' -&gt; 'fuelwood'\"))\n    wood &lt;- wood %&gt;% rename(fuelwood = all_of(poss[1]))\n  }\n}\n\n# Ensure there is a numeric wood density column; prefer 'wood_density'\ndensity_col &lt;- NULL\nif (\"wood_density\" %in% names(wood)) density_col &lt;- \"wood_density\"\nif (is.null(density_col)) {\n  # look for candidates like density, dens_g_cm3, etc.\n  cand &lt;- grep(\"wood.*dens|^density$|dens|g.?/?.?cm3|gcm3|gcc|specific_gravity\", names(wood),\n               ignore.case = TRUE, value = TRUE)\n  if (length(cand) == 0) {\n    stop(\"Could not find a wood density column in the wood densities file.\")\n  } else {\n    density_col &lt;- cand[1]\n    message(glue(\"Using '{density_col}' as wood density and renaming to 'wood_density'\"))\n    wood &lt;- wood %&gt;% rename(wood_density = all_of(density_col))\n  }\n\n# Ensure there is a wood density group column named 'wood_density_group'\nif (!\"wood_density_group\" %in% names(wood)) {\n  cand_grp &lt;- grep(\"group\", names(wood), ignore.case = TRUE, value = TRUE)\n  if (length(cand_grp) &gt; 0) {\n    message(glue(\"Using '{cand_grp[1]}' as wood density group and renaming to 'wood_density_group'\"))\n    wood &lt;- wood %&gt;% rename(wood_density_group = all_of(cand_grp[1]))\n  } else {\n    message(\"No 'wood_density_group' column found in wood densities file; creating as NA.\")\n    wood &lt;- wood %&gt;% mutate(wood_density_group = NA_character_)\n  }\n}\n}\n\n# Normalize the join key for both frames\nmain &lt;- main %&gt;% mutate(fuelwood_key = normalize_key(fuelwood))\nwood &lt;- wood %&gt;% mutate(fuelwood_key = normalize_key(fuelwood))\n\n# Check for missing keys\nmain_missing &lt;- sum(is.na(main$fuelwood_key) | main$fuelwood_key == \"\")\nwood_missing &lt;- sum(is.na(wood$fuelwood_key) | wood$fuelwood_key == \"\")\nmessage(glue(\"Empty/NA fuelwood keys — main: {main_missing}, wood: {wood_missing}\"))\n\n\nEmpty/NA fuelwood keys — main: 0, wood: 0"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html#diagnose-duplicates-in-wood-table-and-de-duplicate-safely",
    "href": "step-2-silcrete_join_wood_density (4).html#diagnose-duplicates-in-wood-table-and-de-duplicate-safely",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "3) Diagnose duplicates in wood table and de-duplicate safely",
    "text": "3) Diagnose duplicates in wood table and de-duplicate safely\n\n\nCode\nwood_dupes &lt;- wood %&gt;%\n  count(fuelwood_key, name = \"n_rows\") %&gt;%\n  filter(n_rows &gt; 1)\n\nif (nrow(wood_dupes) &gt; 0) {\n  message(glue(\"Found {nrow(wood_dupes)} duplicated fuelwood keys in wood densities; aggregating by mean density.\"))\n  # Save the list for review\n  write_csv(wood_dupes, file.path(params$outdir, \"wood_duplicates.csv\"))\n}\n\n# Aggregate wood densities by mean per key to avoid row multiplication on join\nwood_agg &lt;- wood %&gt;%\n  group_by(fuelwood_key) %&gt;%\n  summarise(\n    wood_density = suppressWarnings(mean(as.numeric(wood_density), na.rm = TRUE)),\n    wood_density_group = dplyr::first(na.omit(wood_density_group)),\n    n_source_rows = dplyr::n(),\n    .groups = \"drop\"\n  )"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html#left-join-and-verify",
    "href": "step-2-silcrete_join_wood_density (4).html#left-join-and-verify",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "4) Left join and verify",
    "text": "4) Left join and verify\n\n\nCode\nn_before &lt;- nrow(main)\nmerged &lt;- main %&gt;%\n  left_join(wood_agg, by = \"fuelwood_key\")\n\nn_after &lt;- nrow(merged)\nif (n_after != n_before) {\n  warning(glue(\"Row count changed after join (before: {n_before}, after: {n_after}).\"))\n} else {\n  message(glue(\"Row count unchanged after join: {n_after} rows.\"))\n}\n\n\nRow count unchanged after join: 770 rows.\n\n\nCode\n# How many rows didn't find a wood density?\nn_na_density &lt;- sum(is.na(merged$wood_density))\npct_na &lt;- round(100 * n_na_density / nrow(merged), 2)\nmessage(glue(\"Rows with missing wood_density after join: {n_na_density} ({pct_na}%).\"))\n\n\nRows with missing wood_density after join: 170 (22.08%).\n\n\nCode\n# Identify any fuelwood keys in main that failed to match\nunmatched &lt;- merged %&gt;%\n  filter(is.na(wood_density)) %&gt;%\n  distinct(fuelwood, fuelwood_key) %&gt;%\n  arrange(fuelwood)\nif (nrow(unmatched) &gt; 0) {\n  write_csv(unmatched, file.path(params$outdir, \"unmatched_fuelwood_in_main.csv\"))\n  message(glue(\"Wrote list of unmatched main fuelwood values to 'unmatched_fuelwood_in_main.csv'\"))\n}\n\n\nWrote list of unmatched main fuelwood values to 'unmatched_fuelwood_in_main.csv'\n\n\nCode\n# Keep original fuelwood, drop helper key if you like; retain diagnostic columns\nmerged_out &lt;- merged %&gt;% relocate(wood_density, wood_density_group, .after = fuelwood)\n\n# Quick peek\nmerged_out %&gt;% select(fuelwood, wood_density, wood_density_group) %&gt;% head(12)\n\n\n# A tibble: 12 × 3\n   fuelwood wood_density wood_density_group\n   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;             \n 1 none              NaN &lt;NA&gt;              \n 2 none              NaN &lt;NA&gt;              \n 3 none              NaN &lt;NA&gt;              \n 4 none              NaN &lt;NA&gt;              \n 5 none              NaN &lt;NA&gt;              \n 6 none              NaN &lt;NA&gt;              \n 7 none              NaN &lt;NA&gt;              \n 8 none              NaN &lt;NA&gt;              \n 9 none              NaN &lt;NA&gt;              \n10 none              NaN &lt;NA&gt;              \n11 none              NaN &lt;NA&gt;              \n12 none              NaN &lt;NA&gt;"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html#save-merged-csv",
    "href": "step-2-silcrete_join_wood_density (4).html#save-merged-csv",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "5) Save merged CSV",
    "text": "5) Save merged CSV\n\n\nCode\nout_csv &lt;- file.path(params$outdir, \"wide-to-long_with_wood_density.csv\")\nreadr::write_csv(merged_out, out_csv)\nmessage(glue(\"Saved merged CSV to: {out_csv}\"))\n\n\nSaved merged CSV to: ./wide-to-long_with_wood_density.csv"
  },
  {
    "objectID": "step-2-silcrete_join_wood_density (4).html#summary-tables",
    "href": "step-2-silcrete_join_wood_density (4).html#summary-tables",
    "title": "Join wood densities into wide-to-long dataset",
    "section": "6) Summary tables",
    "text": "6) Summary tables\n\n\nCode\n# Summary by fuelwood\nsummary_by_fuelwood &lt;- merged_out %&gt;%\n  group_by(fuelwood) %&gt;%\n  summarise(\n    n = dplyr::n(),\n    wood_density = unique(wood_density)[1],\n    .groups = \"drop\"\n  ) %&gt;%\n  arrange(fuelwood)\n\n# Density completeness by method/scale/distance/heating\ncompleteness &lt;- merged_out %&gt;%\n  mutate(has_density = !is.na(wood_density)) %&gt;%\n  count(method, scale, distance, heating_condition, has_density) %&gt;%\n  tidyr::pivot_wider(names_from = has_density, values_from = n, values_fill = 0, names_prefix = \"has_density_\") %&gt;%\n  arrange(method, scale, distance, heating_condition)\n\n# Print\nsummary_by_fuelwood %&gt;% head(20) %&gt;% knitr::kable(digits = 3, caption = \"First 20 fuelwood entries with densities\")\n\n\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n\n\nWarning in attr(x, \"format\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n\n\n\nFirst 20 fuelwood entries with densities\n\n\nfuelwood\nn\nwood_density\n\n\n\n\nOlea exasperata\n50\n0.75\n\n\nProtea obtusifolia\n30\n0.58\n\n\nProtea susannae\n20\n0.60\n\n\nPterocelastrus tricuspidatus\n100\n0.65\n\n\nSearsia glauca\n210\n0.72\n\n\nSearsia lucida\n190\n0.70\n\n\nnone\n170\nNaN\n\n\n\n\n\nCode\ncompleteness %&gt;% knitr::kable(digits = 0, caption = \"Wood density completeness by strata\")\n\n\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n\n\n\nWood density completeness by strata\n\n\n\n\n\n\n\n\n\n\nmethod\nscale\ndistance\nheating_condition\nhas_density_TRUE\nhas_density_FALSE\n\n\n\n\nnew method\n10um\nNA\nember\n26\n0\n\n\nnew method\n10um\nNA\nsand\n34\n0\n\n\nnew method\n10um\nNA\nunheated\n0\n17\n\n\nnew method\n20um\nNA\nember\n26\n0\n\n\nnew method\n20um\nNA\nsand\n34\n0\n\n\nnew method\n20um\nNA\nunheated\n0\n17\n\n\nold method\n10um\n0\nember\n26\n0\n\n\nold method\n10um\n0\nsand\n34\n0\n\n\nold method\n10um\n0\nunheated\n0\n17\n\n\nold method\n10um\n0\nember\n26\n0\n\n\nold method\n10um\n0\nsand\n34\n0\n\n\nold method\n10um\n0\nunheated\n0\n17\n\n\nold method\n10um\n1\nember\n26\n0\n\n\nold method\n10um\n1\nsand\n34\n0\n\n\nold method\n10um\n1\nunheated\n0\n17\n\n\nold method\n10um\n2\nember\n26\n0\n\n\nold method\n10um\n2\nsand\n34\n0\n\n\nold method\n10um\n2\nunheated\n0\n17\n\n\nold method\n20um\n0\nember\n26\n0\n\n\nold method\n20um\n0\nsand\n34\n0\n\n\nold method\n20um\n0\nunheated\n0\n17\n\n\nold method\n20um\n0\nember\n26\n0\n\n\nold method\n20um\n0\nsand\n34\n0\n\n\nold method\n20um\n0\nunheated\n0\n17\n\n\nold method\n20um\n1\nember\n26\n0\n\n\nold method\n20um\n1\nsand\n34\n0\n\n\nold method\n20um\n1\nunheated\n0\n17\n\n\nold method\n20um\n2\nember\n26\n0\n\n\nold method\n20um\n2\nsand\n34\n0\n\n\nold method\n20um\n2\nunheated\n0\n17"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "Here we analyze how heating technique (ember vs sand) and wood fuel density affect silcrete flake edge sharpness (average curvature).\n\nExclude unheated observations.\nAnalyze best fit circle method (10 µm and 20 µm).\nAnalyze three point stepping method at distances 0.1, 0.5, 1.0, 2.0 cm and scales 10 µm, 20 µm.\nFit OLS with interaction: average_curvature ~ wood_density_group * heating_condition.\nUse Type II ANOVA and HC3 robust SE for inference.\nReport adjusted means (EMMs) for heating condition (averaged over wood density groups) and, where useful, by each wood density group.\n\n\n\n\nlibrary(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n# Ensure categorical variables are factors for modeling\ndat_filt &lt;- dat_filt %&gt;% mutate(\n  heating_condition = factor(heating_condition),\n  wood_density_group = factor(wood_density_group)\n)\n\n\n\n\n\nfit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, heating_condition, wood_density_group)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ heating_condition * wood_density_group, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  at %&gt;% select(term, everything())\n}\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  # Marginal means for heating_condition, averaging equally over wood_density_group levels\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition)\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  # EMMs for the interaction to visualize two categorical predictors\n  em &lt;- emmeans::emmeans(mdl, ~ heating_condition | wood_density_group)\n  df_em &lt;- as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)\n  ggplot(df_em, aes(x = wood_density_group, y = pred_mean, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), position = position_dodge(width = 0.5), size = 2.5) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), position = position_dodge(width = 0.5), width = 0.2) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    labs(title = title, x = \"Wood density group\", y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) + theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#packages-data",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#packages-data",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "library(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n# Ensure categorical variables are factors for modeling\ndat_filt &lt;- dat_filt %&gt;% mutate(\n  heating_condition = factor(heating_condition),\n  wood_density_group = factor(wood_density_group)\n)"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#helper-functions",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#helper-functions",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "fit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, heating_condition, wood_density_group)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ heating_condition * wood_density_group, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  at %&gt;% select(term, everything())\n}\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  # Marginal means for heating_condition, averaging equally over wood_density_group levels\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition)\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  # EMMs for the interaction to visualize two categorical predictors\n  em &lt;- emmeans::emmeans(mdl, ~ heating_condition | wood_density_group)\n  df_em &lt;- as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)\n  ggplot(df_em, aes(x = wood_density_group, y = pred_mean, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), position = position_dodge(width = 0.5), size = 2.5) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), position = position_dodge(width = 0.5), width = 0.2) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    labs(title = title, x = \"Wood density group\", y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) + theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#summary-figure-old-only",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#summary-figure-old-only",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "3.1 Summary figure (OLD only)",
    "text": "3.1 Summary figure (OLD only)\n\nthree_point_stepping_summary_plot&lt;-if (nrow(adj_means_old) &gt; 0) {\n  ggplot(adj_means_old,\n         aes(x = factor(distance),\n             y = pred_mean,\n             group = interaction(heating_condition, scale),\n             colour = heating_condition, shape = scale, linetype = heating_condition)) +\n    geom_point(position = position_dodge(width = 0.3), size = 2.2) +\n    geom_line(position = position_dodge(width = 0.3)) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high),\n                  width = 0.08, position = position_dodge(width = 0.3)) +\n    scale_colour_manual(values = c(\"sand\"=\"#F26B6B\",\"ember\"=\"#18C3C8\"), name = NULL) +\n    scale_linetype_manual(values = c(\"sand\"=1,\"ember\"=2), name = NULL) +\n    labs(x = \"Distance (cm)\", y = \"Adjusted mean edge sharpness\",\n         title = \"Adjusted means (±95% CI) by heating condition — three point stepping\") +\n    theme_minimal(base_size = 13) +\n    theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#table-1.-data-sample-summary",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#table-1.-data-sample-summary",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "5.1 Table 1. Data sample summary",
    "text": "5.1 Table 1. Data sample summary\nThis table summarizes the analytical sample used in this notebook by method, scale, distance, and heating condition (saved to file)."
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#figures-saved-to-file",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP.html#figures-saved-to-file",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "5.2 Figures (saved to file)",
    "text": "5.2 Figures (saved to file)\nThis recreates the papers plots and exports them to high-resolution PNG and PDF suitable for publication.\n\n\n\n\n\n\n\n\nFigure 1: Comparison of adjusted means: best fit circle vs three point stepping (10µm & 20µm)"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "Here we analyze how heating technique (ember vs sand) and wood fuel density affect silcrete flake edge sharpness (average curvature).\n\nExclude unheated observations.\nAnalyze best fit circle method (10 µm and 20 µm).\nAnalyze three point stepping method at distances 0.1, 0.5, 1.0, 2.0 cm and scales 10 µm, 20 µm.\nFit OLS with interaction: average_curvature ~ wood_density_group * heating_condition.\nUse Type II ANOVA and HC3 robust SE for inference.\nReport adjusted means (EMMs) for heating condition (averaged over wood density groups) and, where useful, by each wood density group.\n\n\n\n\nlibrary(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(effectsize)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n# Ensure categorical variables are factors for modeling\ndat_filt &lt;- dat_filt %&gt;% mutate(\n  heating_condition = factor(heating_condition),\n  wood_density_group = factor(wood_density_group)\n)\n\n\n\n\n\nfit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, heating_condition, wood_density_group)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ heating_condition * wood_density_group, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2, mdl = NULL) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  # Attach partial eta-squared (with 95% CI) by refitting model outside\n  # We rely on a globally available last-fitted model via parent frame when called.\n  # Safer: pass model explicitly where we call tidy_anova.\n  at %&gt;% select(term, everything())\n\n}\n\nadd_effectsizes &lt;- function(a2, mdl) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at); rownames(at) &lt;- NULL\n  # Compute partial eta squared with 95% CI\n  es &lt;- tryCatch({\n    effectsize::eta_squared(mdl, partial = TRUE, ci = 0.95)\n  }, error = function(e) NULL)\n  if (!is.null(es)) {\n    # Normalize column names\n    if ('Parameter' %in% names(es)) es &lt;- dplyr::rename(es, term = Parameter)\n    if ('Eta2_partial' %in% names(es)) es &lt;- dplyr::rename(es, partial_eta2 = Eta2_partial)\n    if ('CI_low' %in% names(es)) es &lt;- dplyr::rename(es, ci_low = CI_low)\n    if ('CI_high' %in% names(es)) es &lt;- dplyr::rename(es, ci_high = CI_high)\n    keep &lt;- intersect(names(es), c('term','partial_eta2','ci_low','ci_high'))\n    es &lt;- es[, keep, drop = FALSE]\n    out &lt;- dplyr::left_join(\n      at %&gt;% dplyr::select(term, dplyr::everything()),\n      es,\n      by = 'term'\n    )\n    return(out)\n  }\n  at\n}\n\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  # Marginal means for heating_condition, averaging equally over wood_density_group levels\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition)\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  # EMMs for the interaction to visualize two categorical predictors\n  em &lt;- emmeans::emmeans(mdl, ~ heating_condition | wood_density_group)\n  df_em &lt;- as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)\n  ggplot(df_em, aes(x = wood_density_group, y = pred_mean, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), position = position_dodge(width = 0.5), size = 2.5) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), position = position_dodge(width = 0.5), width = 0.2) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    labs(title = title, x = \"Wood density group\", y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) + theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#packages-data",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#packages-data",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "library(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(effectsize)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n# Ensure categorical variables are factors for modeling\ndat_filt &lt;- dat_filt %&gt;% mutate(\n  heating_condition = factor(heating_condition),\n  wood_density_group = factor(wood_density_group)\n)"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#helper-functions",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#helper-functions",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "fit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, heating_condition, wood_density_group)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ heating_condition * wood_density_group, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2, mdl = NULL) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  # Attach partial eta-squared (with 95% CI) by refitting model outside\n  # We rely on a globally available last-fitted model via parent frame when called.\n  # Safer: pass model explicitly where we call tidy_anova.\n  at %&gt;% select(term, everything())\n\n}\n\nadd_effectsizes &lt;- function(a2, mdl) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at); rownames(at) &lt;- NULL\n  # Compute partial eta squared with 95% CI\n  es &lt;- tryCatch({\n    effectsize::eta_squared(mdl, partial = TRUE, ci = 0.95)\n  }, error = function(e) NULL)\n  if (!is.null(es)) {\n    # Normalize column names\n    if ('Parameter' %in% names(es)) es &lt;- dplyr::rename(es, term = Parameter)\n    if ('Eta2_partial' %in% names(es)) es &lt;- dplyr::rename(es, partial_eta2 = Eta2_partial)\n    if ('CI_low' %in% names(es)) es &lt;- dplyr::rename(es, ci_low = CI_low)\n    if ('CI_high' %in% names(es)) es &lt;- dplyr::rename(es, ci_high = CI_high)\n    keep &lt;- intersect(names(es), c('term','partial_eta2','ci_low','ci_high'))\n    es &lt;- es[, keep, drop = FALSE]\n    out &lt;- dplyr::left_join(\n      at %&gt;% dplyr::select(term, dplyr::everything()),\n      es,\n      by = 'term'\n    )\n    return(out)\n  }\n  at\n}\n\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  # Marginal means for heating_condition, averaging equally over wood_density_group levels\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition)\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  # EMMs for the interaction to visualize two categorical predictors\n  em &lt;- emmeans::emmeans(mdl, ~ heating_condition | wood_density_group)\n  df_em &lt;- as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)\n  ggplot(df_em, aes(x = wood_density_group, y = pred_mean, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), position = position_dodge(width = 0.5), size = 2.5) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), position = position_dodge(width = 0.5), width = 0.2) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    labs(title = title, x = \"Wood density group\", y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) + theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#summary-figure-old-only",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#summary-figure-old-only",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "3.1 Summary figure (OLD only)",
    "text": "3.1 Summary figure (OLD only)\n\nthree_point_stepping_summary_plot&lt;-if (nrow(adj_means_old) &gt; 0) {\n  ggplot(adj_means_old,\n         aes(x = factor(distance),\n             y = pred_mean,\n             group = interaction(heating_condition, scale),\n             colour = heating_condition, shape = scale, linetype = heating_condition)) +\n    geom_point(position = position_dodge(width = 0.3), size = 2.2) +\n    geom_line(position = position_dodge(width = 0.3)) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high),\n                  width = 0.08, position = position_dodge(width = 0.3)) +\n    scale_colour_manual(values = c(\"sand\"=\"#F26B6B\",\"ember\"=\"#18C3C8\"), name = NULL) +\n    scale_linetype_manual(values = c(\"sand\"=1,\"ember\"=2), name = NULL) +\n    labs(x = \"Distance (cm)\", y = \"Adjusted mean edge sharpness\",\n         title = \"Adjusted means (±95% CI) by heating condition — three point stepping\") +\n    theme_minimal(base_size = 13) +\n    theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#table-1.-data-sample-summary",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#table-1.-data-sample-summary",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "5.1 Table 1. Data sample summary",
    "text": "5.1 Table 1. Data sample summary\nThis table summarizes the analytical sample used in this notebook by method, scale, distance, and heating condition (saved to file)."
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#figures-saved-to-file",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (1).html#figures-saved-to-file",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "5.2 Figures (saved to file)",
    "text": "5.2 Figures (saved to file)\nThis recreates the papers plots and exports them to high-resolution PNG and PDF suitable for publication.\n\n\n\n\n\n\n\n\nFigure 1: Comparison of adjusted means: best fit circle vs three point stepping (10µm & 20µm)"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "Here we analyze how heating technique (ember vs sand) and wood fuel density affect silcrete flake edge sharpness (average curvature).\n\nExclude unheated observations.\nAnalyze best fit circle method (10 µm and 20 µm).\nAnalyze three point stepping method at distances 0.1, 0.5, 1.0, 2.0 cm and scales 10 µm, 20 µm.\nFit OLS with interaction: average_curvature ~ wood_density_group * heating_condition.\nUse Type II ANOVA and HC3 robust SE for inference.\nReport adjusted means (EMMs) for heating condition (averaged over wood density groups) and, where useful, by each wood density group.\n\n\n\n\nlibrary(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(effectsize)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n# Ensure categorical variables are factors for modeling\ndat_filt &lt;- dat_filt %&gt;% mutate(\n  heating_condition = factor(heating_condition),\n  wood_density_group = factor(wood_density_group)\n)\n\n\n\n\n\nfit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, heating_condition, wood_density_group)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ heating_condition * wood_density_group, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2, mdl = NULL) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  # Attach partial eta-squared (with 95% CI) by refitting model outside\n  # We rely on a globally available last-fitted model via parent frame when called.\n  # Safer: pass model explicitly where we call tidy_anova.\n  at %&gt;% select(term, everything())\n\n}\n\nadd_effectsizes &lt;- function(a2, mdl) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at); rownames(at) &lt;- NULL\n  # Compute partial eta squared with 95% CI\n  es &lt;- tryCatch({\n    effectsize::eta_squared(mdl, partial = TRUE, ci = 0.95)\n  }, error = function(e) NULL)\n  if (!is.null(es)) {\n    # Normalize column names\n    if ('Parameter' %in% names(es)) es &lt;- dplyr::rename(es, term = Parameter)\n    if ('Eta2_partial' %in% names(es)) es &lt;- dplyr::rename(es, partial_eta2 = Eta2_partial)\n    if ('CI_low' %in% names(es)) es &lt;- dplyr::rename(es, ci_low = CI_low)\n    if ('CI_high' %in% names(es)) es &lt;- dplyr::rename(es, ci_high = CI_high)\n    keep &lt;- intersect(names(es), c('term','partial_eta2','ci_low','ci_high'))\n    es &lt;- es[, keep, drop = FALSE]\n    out &lt;- dplyr::left_join(\n      at %&gt;% dplyr::select(term, dplyr::everything()),\n      es,\n      by = 'term'\n    )\n    return(out)\n  }\n  at\n}\n\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  # Marginal means for heating_condition, averaging equally over wood_density_group levels\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition)\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  # EMMs for the interaction to visualize two categorical predictors\n  em &lt;- emmeans::emmeans(mdl, ~ heating_condition | wood_density_group)\n  df_em &lt;- as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)\n  ggplot(df_em, aes(x = wood_density_group, y = pred_mean, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), position = position_dodge(width = 0.5), size = 2.5) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), position = position_dodge(width = 0.5), width = 0.2) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    labs(title = title, x = \"Wood density group\", y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) + theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#packages-data",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#packages-data",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "library(tidyverse)\nlibrary(car)\nlibrary(sandwich)\nlibrary(lmtest)\nlibrary(emmeans)\nlibrary(broom)\nlibrary(effectsize)\nlibrary(tibble)\n\ndata_path &lt;- \"wide-to-long_with_wood_density.csv\"\ndat &lt;- readr::read_csv(data_path, show_col_types = FALSE)\n\ndat &lt;- dat %&gt;%\n  mutate(\n    method = dplyr::recode(tolower(method),\n    \"old method\" = \"three point stepping\",\n    \"new method\" = \"best fit circle\"\n  ),\n    scale = tolower(as.character(scale)),\n    treatment = as.character(treatment),\n    heating_condition = tolower(as.character(heating_condition)),\n    distance = suppressWarnings(as.numeric(distance))\n  )\n# Exclude unheated\ndat_filt &lt;- dat %&gt;% filter(!treatment %in% c(\"Unheated\", \"unheated\"))\n\n# Ensure categorical variables are factors for modeling\ndat_filt &lt;- dat_filt %&gt;% mutate(\n  heating_condition = factor(heating_condition),\n  wood_density_group = factor(wood_density_group)\n)"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#helper-functions",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#helper-functions",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "",
    "text": "fit_int_model &lt;- function(df) {\n  df &lt;- df %&gt;% drop_na(average_curvature, heating_condition, wood_density_group)\n  if (nrow(df) &lt; 5) return(NULL)\n  m &lt;- lm(average_curvature ~ heating_condition * wood_density_group, data = df)\n  a2 &lt;- tryCatch(\n    car::Anova(m, type = 2, white.adjust = \"hc3\"),\n    error = function(e) car::Anova(m, type = 2)\n  )\n  list(model = m, anova2 = a2)\n}\n\ntidy_anova &lt;- function(a2, mdl = NULL) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at)\n  rownames(at) &lt;- NULL\n  # Attach partial eta-squared (with 95% CI) by refitting model outside\n  # We rely on a globally available last-fitted model via parent frame when called.\n  # Safer: pass model explicitly where we call tidy_anova.\n  at %&gt;% select(term, everything())\n\n}\n\nadd_effectsizes &lt;- function(a2, mdl) {\n  at &lt;- as.data.frame(a2)\n  at$term &lt;- rownames(at); rownames(at) &lt;- NULL\n  # Compute partial eta squared with 95% CI\n  es &lt;- tryCatch({\n    effectsize::eta_squared(mdl, partial = TRUE, ci = 0.95)\n  }, error = function(e) NULL)\n  if (!is.null(es)) {\n    # Normalize column names\n    if ('Parameter' %in% names(es)) es &lt;- dplyr::rename(es, term = Parameter)\n    if ('Eta2_partial' %in% names(es)) es &lt;- dplyr::rename(es, partial_eta2 = Eta2_partial)\n    if ('CI_low' %in% names(es)) es &lt;- dplyr::rename(es, ci_low = CI_low)\n    if ('CI_high' %in% names(es)) es &lt;- dplyr::rename(es, ci_high = CI_high)\n    keep &lt;- intersect(names(es), c('term','partial_eta2','ci_low','ci_high'))\n    es &lt;- es[, keep, drop = FALSE]\n    out &lt;- dplyr::left_join(\n      at %&gt;% dplyr::select(term, dplyr::everything()),\n      es,\n      by = 'term'\n    )\n    return(out)\n  }\n  at\n}\n\n\nemmeans_by_heat &lt;- function(mdl, df) {\n  # Marginal means for heating_condition, averaging equally over wood_density_group levels\n  em &lt;- emmeans::emmeans(mdl, specs = ~ heating_condition)\n  as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n}\n\n\n# Plot in requested style\nplot_interaction_custom &lt;- function(mdl, df, title) {\n  # EMMs for the interaction to visualize two categorical predictors\n  em &lt;- emmeans::emmeans(mdl, ~ heating_condition | wood_density_group)\n  df_em &lt;- as.data.frame(summary(em)) %&gt;%\n    rename(pred_mean = emmean, ci_low = lower.CL, ci_high = upper.CL)\n  cols &lt;- c(\"sand\" = \"#F26B6B\", \"ember\" = \"#18C3C8\")\n  shapes &lt;- c(\"sand\" = 16, \"ember\" = 17)\n  ggplot(df_em, aes(x = wood_density_group, y = pred_mean, colour = heating_condition)) +\n    geom_point(aes(shape = heating_condition), position = position_dodge(width = 0.5), size = 2.5) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high), position = position_dodge(width = 0.5), width = 0.2) +\n    scale_colour_manual(values = cols, name = NULL) +\n    scale_shape_manual(values = shapes, name = NULL) +\n    labs(title = title, x = \"Wood density group\", y = \"Edge sharpness (average curvature)\") +\n    theme_minimal(base_size = 13) + theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#summary-figure-old-only",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#summary-figure-old-only",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "3.1 Summary figure (OLD only)",
    "text": "3.1 Summary figure (OLD only)\n\nthree_point_stepping_summary_plot&lt;-if (nrow(adj_means_old) &gt; 0) {\n  ggplot(adj_means_old,\n         aes(x = factor(distance),\n             y = pred_mean,\n             group = interaction(heating_condition, scale),\n             colour = heating_condition, shape = scale, linetype = heating_condition)) +\n    geom_point(position = position_dodge(width = 0.3), size = 2.2) +\n    geom_line(position = position_dodge(width = 0.3)) +\n    geom_errorbar(aes(ymin = ci_low, ymax = ci_high),\n                  width = 0.08, position = position_dodge(width = 0.3)) +\n    scale_colour_manual(values = c(\"sand\"=\"#F26B6B\",\"ember\"=\"#18C3C8\"), name = NULL) +\n    scale_linetype_manual(values = c(\"sand\"=1,\"ember\"=2), name = NULL) +\n    labs(x = \"Distance (cm)\", y = \"Adjusted mean edge sharpness\",\n         title = \"Adjusted means (±95% CI) by heating condition — three point stepping\") +\n    theme_minimal(base_size = 13) +\n    theme(legend.position = \"top\")\n}"
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#table-1.-data-sample-summary",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#table-1.-data-sample-summary",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "5.1 Table 1. Data sample summary",
    "text": "5.1 Table 1. Data sample summary\nThis table summarizes the analytical sample used in this notebook by method, scale, distance, and heating condition (saved to file)."
  },
  {
    "objectID": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#figures-saved-to-file",
    "href": "step-3_silcrete_edge_sharpness_analysis-WOODGROUP (2).html#figures-saved-to-file",
    "title": "Silcrete Edge Sharpness: Heating Technique vs. Wood Density Group",
    "section": "5.2 Figures (saved to file)",
    "text": "5.2 Figures (saved to file)\nThis recreates the papers plots and exports them to high-resolution PNG and PDF suitable for publication.\n\n\n\n\n\n\n\n\nFigure 1: Comparison of adjusted means: best fit circle vs three point stepping (10µm & 20µm)"
  }
]